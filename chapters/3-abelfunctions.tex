%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Abelfunctions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The primary result of this thesis is the Sage software library Abelfunctions
\cite{abelfunctions}. The goal of Abelfunctions is to provide general and easy
to use framework for computing with Abelian functions, Riemann surfaces, and
algebraic curves.

Abelfunctions was inspired by the Maple software package Algcurves developed by
Deconinck, van Hoeij, and Patterson \cite{algcurves}. The need for Abelfunctions
grew out of the difficulty in keeping Algcurves up to date within Maple's
proprietary software. Because of the need to resolve issues as they are
encountered as well as allowing the ability to improve upon the software when
new algorithms are developed, Abelfunctions was created using a completely
open-source model within completely open-source software.

Abelfunctions differs from Algcurves in two main ways. First, the opportunity
write a new a software package for computing with Riemann surfaces invites the
opportunity to investigate better software design. The philosophy of design is
first influenced by the choice of the Python/Sage language which offers features
not availble in Maple. Furthermore, the use of object-oriented design offers the
ability to more easily improve upon Abelfunctions in the future. Following these
well-studied object-oriented design patterns \cite{gamma1995design} is in line
with the reproducibility movement spreading in the computational sciences
\cite{stodden2012reproducible} which encourages the release of well-designed and
well-documented code used in any scientific endeavor which makes use of
computational results.

Second, the opportunity to implement the functionality of Algcurves in a
different environment provided the opportunity to improve upon existing
algorithms. The path from plane algebraic curve to period matrix, Abel map, and
Riemann constant vector draws from a diverse set of algorithms used to realize
the intermediate steps leading to these goals.

This software can be obtained on GitHub at
\url{http://github.com/abelfunctions}. Developers are encouraged to examine
Appendix [XXX] where a description of the implementation details of version
[XXX] are provided; the most recent version of the software at the time of this
writing.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reproducibility and Scientific Software Design}\label{sec:reproducibility}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Reproducibility is standard practice in the physical sciences. When sharing
research with the scientific community one should provide sufficient detail of
the experimental setup, performance metrics, and observations for a second party
to repeat the experiment. Whatever the state of reproducibility is in physical
science some have observed that field of computational science is lagging
behind. From the generation of figures to the demonstration of newly developed
algorithms many papers display these results without providing the means of
generating these data: the source code.

During the development of WaveLab, Buckheit and Donoho created the following
slogan,
\begin{quotation}
  An article about computational science in a scientifc publication is not the
  scholarship itself, it is merely advertising of the scholarship. The actual
  scholarship is the complete software development environment and the complete
  set of instructions which generated the figures \cite{buckheit1995wavelab}.
\end{quotation}
The [XXX][FINISH]

To read more about the reproducibility movement in computational science see
\cite{peng2011reproducible}, \cite{stodden2012reproducible}, and
\cite{stodden2013best}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Brief Look at Object-Oriented Design}\label{sec:object-oriented-design}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Robert Martin succinctly addresses what goes wrong with software once it
achieves non-trivial levels of complexity with a list of four symptoms of
rotting design \cite{martin2000design}. The common element across these symptoms
is that rotting design adds developer time and reduces manager and customer
trust.
\begin{itemize}
\item {\bf Rigidity} - the tendency for software to be difficult to change. When
  a simple fix should take several days but instead takes weeks, managers and
  advisors are reluctant to let developers address non-critical issues.
\item {\bf Fragility} - the tendency for software to break, potentially in many
  places, every time it is changed. Fragile software creates connections between
  parts of code that are supposed to be logically distinct.
\item {\bf Immobility} - the inability to reuse software from parts of other
  projects or the same project. The more extraneous components a software
  component has the less potential it has to be generalized. [XXX] When
  immobility is high the amount of work required to separate out potentially
  resuable parts of code is greater than the work it takes to rewrite the code
  entirely.
\item {\bf Viscosity} - the situation where, when making a code change, the
  approach that preserves the software design is more expensive than the
  approach that does not. Viscous software encourages ``hacks'' as solutions to
  problems rather than coherent modifications.
\end{itemize}

\subsection{Objects in Python and Sage}

\subsection{Inheritance}

\subsection{Composition}

\subsection{Strategy Design Pattern}

\subsection{Dependency Inversion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Tour of Abelfunctions}\label{sec:abelfunctions-a-tour-of-abelfunctions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{quote}
  In this section we demonstrate the various capabilities of the Abelfunctions
  library. The full source code of this demonstration can be found at
  \url{https://github.com/cswiercz/thesis} in the {\tt code} directory as a
  Jupyter notebook.
\end{quote}

Abelfunctions several top-level functions and objects. The user takes advantage
of the Abelfunctions functionality primarily through these objects.
\begin{itemize}
  \item {\tt RiemannSurface} - principle object, defines a Riemann surface given
    a bivariate Sage polynomial.
  \item {\tt AbelMap} - defines the Abel map function from one place on a
    Riemann surface to another. Can accept divisors as well.
  \item {\tt RiemannConstantVector} - defined the Riemann constant vector
    function as a function of an arbitrary place on a Riemann surface.
  \item {\tt RiemannTheta} - the Riemann theta function as a function from
    $\CC^g \times \hg$ to $\CC$.
\end{itemize}

\noindent We begin by importing this functionality and constructing a Riemann
surface corresponding to the plane algebraic curve,

\[
  C : x^2y^3 - x^4 + 1 = 0, \quad x,y \in \CC^*.
\]

\begin{lstlisting}[language=Sage]
sage: from abelfunctions import *  # import the main Abelfunctions functionality
sage: R.<x,y> = QQ[]  # construct a Sage polynomial ring and the above curve
sage: f = y**3 - 2*x**3*y + x**7
sage: X = RiemannSurface(f); X  # construct the corresponding Riemann surface
Riemann surface defined by f = x^7 - 2*x^3*y + y^3
\end{lstlisting}

\noindent The genus of the curve is determined using the singularity structure.
In this case, the Riemann surface is of genus four.

\begin{lstlisting}[language=Sage]
sage: g = X.genus(); g
4
\end{lstlisting}

\noindent We can verify this with the singularity data.

\begin{lstlisting}[language=Sage]
sage: from abelfunctions.singularities import singularities
sage: for point, (m, delta, r) in singularities(f):
 ...:     print point, '\tdelta invariant =', delta
(0, 1, 0)    delta invariant = 2
sage: d = f.total_degree()
sage: g = (d-1)*(d-2)/2 - 2  # (-2) from the delta inv. above
sage: g
4
\end{lstlisting}

%------------------------------------------------------------------------------
\subsection{Places and Divisors}
% ------------------------------------------------------------------------------

The curve $C$ has the branch points,

\begin{lstlisting}[language=Sage]
sage: b = X.branch_points; b
[-1*I, -1, 0, 1, 1*I, +Infinity]
\end{lstlisting}

\noindent This implies that at least one of the places above each of these
points is ramified. In fact, in this example each branch point has a
fully-ramified place lying above it on the Riemann surface.

\begin{lstlisting}[language=Sage]
sage: places = X(0)
sage: for P in places: print P
(-t^3, -t^-2 + O(t^0))
sage: P.puiseux_series.extend(16); P
(-t^3, -t^-2 + 1/3*t^10 + 1/9*t^22 + O(t^31))
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Improvements on
  Algorithms}\label{sec:abelfunctions-improvements-on-algorithms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Analytic
  Continuation}\label{subsec:abelfunctions-analytic-continuation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integration}\label{subsec:abelfunctions-integration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Riemann Constant
  Vector}\label{subsec:abelfunctions-riemann-constant-vector}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
